<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[各种排序算法]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[二叉树的遍历与相关应用]]></title>
    <url>%2F2018%2F10%2F29%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[先序遍历中序遍历后序遍历打印叶子结点求树的高度二元运算表达式树及其遍历]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 4.两个排序数组的中位数]]></title>
    <url>%2F2018%2F10%2F28%2FLeetCode-4-%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 3.无重复字符的最长子串]]></title>
    <url>%2F2018%2F10%2F28%2FLeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[各种查找算法]]></title>
    <url>%2F2018%2F10%2F27%2F%E5%90%84%E7%A7%8D%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"></content>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 文章模版]]></title>
    <url>%2F2018%2F10%2F26%2FLeetCode-%E6%96%87%E7%AB%A0%E6%A8%A1%E7%89%88%2F</url>
    <content type="text"><![CDATA[题目给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例: 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 C++版12 Ruby版12]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 2.两数相加]]></title>
    <url>%2F2018%2F10%2F26%2FLeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[题目给定两个非空链表来表示两个非负整数。 位数按照逆序方式存储，它们的每个节点只存储单个数字。 将两数相加返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例: 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 C++版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;iostream&gt;using namespace std;struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* res = (ListNode*)malloc(sizeof(ListNode)); ListNode* head = NULL; //是否进位 int flag = 0; ListNode* t1 = l1; ListNode* t2 = l2; //先算l1与l2等长部分相加 while(t1 != NULL &amp;&amp; t2 != NULL )&#123; ListNode* temp = (ListNode*)malloc(sizeof(ListNode)); int sum = 0; sum = t1-&gt;val + t2-&gt;val + flag; if(sum &gt;= 10) &#123; temp-&gt;val = sum % 10; flag = 1; &#125;else &#123; temp-&gt;val = sum; flag = 0; &#125; if( head == NULL ) &#123; temp-&gt;next = NULL; head = temp; res = head; &#125;else&#123; res-&gt;next = temp; res = temp; &#125; t1 = t1-&gt;next; t2 = t2-&gt;next; &#125; //t1剩余部分 while(t1 != NULL)&#123; ListNode* temp = (ListNode*)malloc(sizeof(ListNode)); int sum = 0; sum = t1-&gt;val + flag; if(sum &gt;= 10)&#123; temp-&gt;val = sum % 10; flag = 1; &#125;else&#123; temp-&gt;val = sum; flag = 0; &#125; temp-&gt;next = NULL; res-&gt;next = temp; res = temp; t1 = t1-&gt;next; &#125; //t2剩余部分 while(t2 != NULL) &#123; ListNode* temp = (ListNode*)malloc(sizeof(ListNode)); int sum = 0; sum = t2-&gt;val + flag; if(sum &gt;= 10)&#123; temp-&gt;val = sum % 10; flag = 1; &#125;else&#123; temp-&gt;val = sum; flag = 0; &#125; temp-&gt;next = NULL; res-&gt;next = temp; res = temp; t2 = t2-&gt;next; &#125; //是否进位 if(flag) &#123; ListNode* temp = (ListNode*)malloc(sizeof(ListNode)); temp-&gt;val = 1; temp-&gt;next = NULL; res-&gt;next = temp; &#125; return head; &#125;&#125;;int main() &#123; ListNode* l1 = (ListNode*)malloc(sizeof(ListNode)); ListNode* h1 = NULL; ListNode* l2 = (ListNode*)malloc(sizeof(ListNode)); ListNode* h2 = NULL; ListNode* res = (ListNode*)malloc(sizeof(ListNode)); int a1[3] = &#123;2, 4, 3&#125;; int a2[3] = &#123;5, 6, 4&#125;; for(int i=0; i &lt; 3; i++) &#123; ListNode* temp = (ListNode*)malloc(sizeof(ListNode)); temp-&gt;val = a1[i]; if(h1 == NULL) &#123; temp-&gt;next = NULL; l1 = temp; h1 = l1; &#125;else&#123; temp-&gt;next =NULL; h1-&gt;next = temp; h1 = temp; &#125; &#125; for(int i=0; i &lt; 3; i++) &#123; ListNode* temp = (ListNode*)malloc(sizeof(ListNode)); temp-&gt;val = a2[i]; if(h2 == NULL) &#123; temp-&gt;next = NULL; l2 = temp; h2 = l2; &#125;else&#123; temp-&gt;next =NULL; h2-&gt;next = temp; h2 = temp; &#125; &#125; Solution* s = new Solution(); res = s-&gt;addTwoNumbers(l1, l2); while(res != NULL) &#123; cout&lt;&lt;res-&gt;val&lt;&lt;endl; res = res-&gt;next; &#125; return 0;&#125; Ruby版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class ListNode attr_accessor :val, :next def initialize(val) @val = val @next = nil endend# @param &#123;ListNode&#125; l1# @param &#123;ListNode&#125; l2# @return &#123;ListNode&#125;def add_two_numbers(l1, l2) #头结点 result = res = ListNode.new(-1) #是否进位 flag = 0 #同位相加 while(l1 &amp;&amp; l2) sum = l1.val + l2.val + flag if sum &gt;= 10 flag = 1 else flag = 0 end #puts res.val # 是否为头结点 if res.val != -1 res.next = ListNode.new(sum % 10) res = res.next else res.val = sum % 10 end l1 = l1.next l2 = l2.next end #l1剩余部分 while(l1) sum = l1.val + flag if sum &gt;= 10 flag = 1 else flag = 0 end res.next = ListNode.new(sum % 10) l1 = l1.next res = res.next end #l2剩余部分 while(l2) sum = l2.val + flag if sum &gt;= 10 flag = 1 else flag = 0 end res.next = ListNode.new(sum % 10) l2 = l2.next res = res.next end #末尾是否还有进位 if flag == 1 res.next = ListNode.new(1) end resultendl1 = ListNode.new(1)l2 = ListNode.new(2)r = add_two_numbers(l1, l2)while r puts r.val r = r.nextend]]></content>
  </entry>
  <entry>
    <title><![CDATA[markdown常用语法]]></title>
    <url>%2F2018%2F10%2F24%2Fmarkdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[vector的用法]]></title>
    <url>%2F2018%2F10%2F24%2Fvector%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>vector</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1.两数之和]]></title>
    <url>%2F2018%2F10%2F22%2FLeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] C++版1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; int length = nums.size(); vector&lt;int&gt; result; for (int i = 0; i &lt; length; ++i) &#123; for (int j = i+1; j &lt; length; ++j) &#123; if (nums[i] + nums[j] == target) &#123; result.push_back(i); result.push_back(j); break; &#125; &#125; &#125; return result; &#125;&#125;;int main() &#123; int a[6] = &#123;1,6,8,4,10,7&#125;; vector&lt;int&gt; b; vector&lt;int&gt; result; int target = 9; b.insert(b.begin(), a, a + 6); Solution *s = new Solution(); result = s-&gt;twoSum(b, target); cout&lt;&lt;"["&lt;&lt;result[0]&lt;&lt;","&lt;&lt;result[1]&lt;&lt;"]"&lt;&lt;endl; return 0;&#125; Ruby版123456789101112131415161718192021# @param &#123;Integer[]&#125; nums# @param &#123;Integer&#125; target# @return &#123;Integer[]&#125;def two_sum(nums, target) i = 0 j = 1 while i &lt; nums.size j = i + 1 while j &lt; nums.size if nums[i] + nums[j] == target return i, j else j += 1 end end i += 1 endendnums = [9, 12, 3, 4, 51, 6, 8]puts two_sum(nums, 11)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乐观锁与悲观锁]]></title>
    <url>%2F2018%2F10%2F18%2F%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F10%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式1.Singleton（单例）模式用来保证某个类的实例只有一个。如果这个类的实例已存在则返回，不存在则创建。主要作用:作为其他对象的雏形而存在的对象，以及系统全体只存在唯一一个的对象2.Proxy（代理）模式为某个对象提供代理对象的模式。主要作用:某对象的生成代价非常大，如果还不知道是否真正的需要该对象时就事先把它生成，可能带来很大的浪费。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Error: xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun]]></title>
    <url>%2F2018%2F10%2F14%2FError-xcrun-error-invalid-active-developer-path-Library-Developer-CommandLineTools-missing-xcrun-at-Library-Developer-CommandLineTools-usr-bin-xcrun%2F</url>
    <content type="text"><![CDATA[MacOS下出现如下错误: xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun 解决方案1$ xcode-select --install]]></content>
      <tags>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[升级Mojave,出现安装macOS时发生错误或者无法验证macOS]]></title>
    <url>%2F2018%2F10%2F14%2F%E5%8D%87%E7%BA%A7Mojave-%E5%87%BA%E7%8E%B0%E5%AE%89%E8%A3%85macOS%E6%97%B6%E5%8F%91%E7%94%9F%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[升级Mojave,出现安装macOS时发生错误的解决方案 解决方法:系统偏好设置-&gt;网络-&gt;高级-&gt;DNS-&gt;改成8.8.8.8………………..………………..本以为这样就可以了，然而等了半个小时后还是无法验证macOS，然后上网搜了一堆解决方案，各种设置，重启，重新下载，安全模式等，都是碰巧。从错误提示分析，无法验证xxx，估计网络不好或者信息不匹配，信息不匹配不容易找具体原因，而网络不好估计并不是真正的网络不好，而是要科学上网。科学上网后再升级，一次就完美升级。]]></content>
      <tags>
        <tag>Mojave macOS升级 解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetbrains系列产品2018.2.4最新激活方法]]></title>
    <url>%2F2018%2F10%2F14%2FJetbrains%E7%B3%BB%E5%88%97%E4%BA%A7%E5%93%812018-2-4%E6%9C%80%E6%96%B0%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.访问下面的网站，并下载图中所示文件http://idea.lanyus.com/ 2.打开你所用的Jetbrains产品，并按照图中操作创建相关文件 3.编辑刚才创建的文件，然后在最末尾加上 -javaagent:JetbrainsCrack-3.1-release-enc.jar 即可。4.重启5.获取注册码，激活。]]></content>
      <tags>
        <tag>Jetbrains</tag>
        <tag>激活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo中不蒜子404错误解决方案]]></title>
    <url>%2F2018%2F10%2F11%2F%E4%B8%8D%E8%92%9C%E5%AD%90404%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[今天上博客突然发现网站统计人数的插件，不蒜子出现404错误，然后访问该网址，返回没有此域名的结果，最终到不蒜子官网找到原因 解决方法到themes/next/layout/_third-party/analytics/busuanzi-counter.swig替换一下网址即可 完。]]></content>
      <tags>
        <tag>解决方案</tag>
        <tag>hexo</tag>
        <tag>不蒜子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js]]></title>
    <url>%2F2018%2F09%2F28%2Fjs%2F</url>
    <content type="text"></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css]]></title>
    <url>%2F2018%2F09%2F28%2Fcss%2F</url>
    <content type="text"></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html]]></title>
    <url>%2F2018%2F09%2F28%2Fhtml%2F</url>
    <content type="text"></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular]]></title>
    <url>%2F2018%2F09%2F28%2Fangular%2F</url>
    <content type="text"></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rails常用命令]]></title>
    <url>%2F2018%2F09%2F26%2FRails%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.Rails启动1$ rails s 2.生成控制器 + 动作1$ rails g controller Welcome(控制器) index(动作) 3.REST资源生成在route.rb中添加resource :articles生成资源路由1$ rails routes 4.创建模型1$ rails g model Article(模型名称) title:string text:text 5.运行迁移1$ rails db:migrate 6.在其他环境运行迁移，如生产环境production,测试环境test1$ rails db:migrate RAILS_ENV=production 7.数据回滚1$ rails db:rollback 8.创建迁移123$ rails g migration AddPartNumberToProducts(AddXXXToYYY或者RemoveXXXFromYYY)$ rails g migration AddPartNumberToProducts part_number:string 9.添加索引1$ rails g migration AddPartNumberToProducts part_number:string:index 10.删除字段1$ rails g migration RemovePartNumberFromProducts part_number:string 11.添加新模型1$ rails g model Product name:string description:text 12.传递修饰符12$ rails g migration AddDetailsToProducts'price:decimal&#123;5,2&#125;' supplier:references&#123;polymorphic&#125; 13.回滚X步1$ rails db:rollback STEP=3 14.回滚最后X个迁移并再次运行迁移1$ rails db:migrate:redo STEP=3 15.安装数据库1$ rails db:setup 16.安装数据库1$ rails db:reset #相当于rails db:drop db:setup 17.运行指定迁移1$ rails db:migrate:up VERSION=xxxxxxxxxxxxxxxx(如20180912120000) 18.种子数据1$ rails db:seed #需先填充db/seed.rb文件]]></content>
      <categories>
        <category>Rails</category>
      </categories>
      <tags>
        <tag>Rails</tag>
      </tags>
  </entry>
</search>
