<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Docker命令]]></title>
    <url>%2F2018%2F12%2F14%2FDocker%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.查看Docker版本1docker version]]></content>
  </entry>
  <entry>
    <title><![CDATA[Rails5 安装bcrypt报错 An error occurred while installing bcrypt (3.1.12), and Bundler cannot continue.]]></title>
    <url>%2F2018%2F12%2F13%2FRails5-%E5%AE%89%E8%A3%85bcrypt%E6%8A%A5%E9%94%99-An-error-occurred-while-installing-bcrypt-3-1-12-and-Bundler-cannot-continue%2F</url>
    <content type="text"><![CDATA[按照《Rails5敏捷开发》教程进行到第14章–用户登录功能，User表中的密码字段需要存储为指纹哈希值，因此需要用到bcrypt.按照书上添加gem ‘bcrypt’, ‘~&gt;3.1.7’1bundle install 结果报错 谷歌到这些解决方法1.https://stackoverflow.com/questions/37158550/an-error-occurred-while-installing-bcrypt-3-1-11-and-bundler-cannot-continue2.http://www.itdaan.com/blog/2018/05/26/75c1d12cf8462711dd890e28d30947f.html3.https://community.bitnami.com/t/bcrypt-gem-failing-to-install-mac-os-x/214774.http://blog.champierre.com/10245.这个跟我报的错误一模一样,但我用这个方法还是不行 https://qiita.com/knoel/items/2aa35c9a5c34b3aea9286.这个是bcrpty-ruby中的issue https://github.com/codahale/bcrypt-ruby/issues/102 以上都不能解决此报错问题，请大佬帮忙看看Gemfile1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768source 'https://rubygems.org'git_source(:github) &#123; |repo| "https://github.com/#&#123;repo&#125;.git" &#125;ruby '2.3.7'# Bundle edge Rails instead: gem 'rails', github: 'rails/rails'gem 'rails', '~&gt; 5.2.2'# Use sqlite3 as the database for Active Recordgem 'sqlite3'# Use Puma as the app servergem 'puma', '~&gt; 3.11'# Use SCSS for stylesheetsgem 'sass-rails', '~&gt; 5.0'# Use Uglifier as compressor for JavaScript assetsgem 'uglifier', '&gt;= 1.3.0'# See https://github.com/rails/execjs#readme for more supported runtimes# gem 'mini_racer', platforms: :ruby#gem 'jquery-rails', '~&gt; 4.3', '&gt;= 4.3.3'gem 'jquery-ui-rails'# Use CoffeeScript for .coffee assets and viewsgem 'coffee-rails', '~&gt; 4.2'# Turbolinks makes navigating your web application faster. Read more: https://github.com/turbolinks/turbolinksgem 'turbolinks', '~&gt; 5'# Build JSON APIs with ease. Read more: https://github.com/rails/jbuildergem 'jbuilder', '~&gt; 2.5'# Use Redis adapter to run Action Cable in production# gem 'redis', '~&gt; 4.0'# Use ActiveModel has_secure_passwordgem 'bcrypt', '~&gt; 3.1.7'# gem 'bcrypt', platforms: :ruby# gem 'bcrypt', git: 'https://github.com/codahale/bcrypt-ruby.git', :require =&gt; 'bcrypt'#gem 'bcrypt', '~&gt; 3.1', '&gt;= 3.1.12'# Use ActiveStorage variant# gem 'mini_magick', '~&gt; 4.8'# Use Capistrano for deployment# gem 'capistrano-rails', group: :development# Reduces boot times through caching; required in config/boot.rbgem 'bootsnap', '&gt;= 1.1.0', require: falsegroup :development, :test do # Call 'byebug' anywhere in the code to stop execution and get a debugger console gem 'byebug', platforms: [:mri, :mingw, :x64_mingw]endgroup :development do # Access an interactive console on exception pages or by calling 'console' anywhere in the code. gem 'web-console', '&gt;= 3.3.0' gem 'listen', '&gt;= 3.0.5', '&lt; 3.2' # Spring speeds up development by keeping your application running in the background. Read more: https://github.com/rails/spring gem 'spring' gem 'spring-watcher-listen', '~&gt; 2.0.0'endgroup :test do # Adds support for Capybara system testing and selenium driver gem 'capybara', '&gt;= 2.15' gem 'selenium-webdriver' # Easy installation and use of chromedriver to run system tests with Chrome gem 'chromedriver-helper'end# Windows does not include zoneinfo files, so bundle the tzinfo-data gemgem 'tzinfo-data', platforms: [:mingw, :mswin, :x64_mingw, :jruby] 电脑是MacPro2018最新款,操作系统升级到最新版的macOS Mojave.本项目源码:https://github.com/yuanchang2018/depot]]></content>
  </entry>
  <entry>
    <title><![CDATA[Rails5 Action Mailer 发送电子邮件--以QQ邮箱为例]]></title>
    <url>%2F2018%2F12%2F11%2FRails5-Action-Mailer-%E5%8F%91%E9%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6-%E4%BB%A5QQ%E9%82%AE%E7%AE%B1%E4%B8%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[config/environments/development.rb123456789101112131415Depot::Application.configure do config.action_mailer.delivery_method = :smtp config.action_mailer.perform_deliveries = true config.action_mailer.raise_delivery_errors = true config.action_mailer.smtp_settings = &#123; address: "smtp.qq.com", port: 25, domain: "qq.com", authentication: :plain, user_name: "your_email", password: "your_password", enable_starttls_auto: true &#125; end port应该为25，被官方文档坑了,试了半天的465,587都不对]]></content>
  </entry>
  <entry>
    <title><![CDATA[《Rails5敏捷开发》书中的一些可以改进的地方]]></title>
    <url>%2F2018%2F12%2F08%2F%E3%80%8ARails5%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E3%80%8B%E4%B9%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%AF%E4%BB%A5%E6%94%B9%E8%BF%9B%E7%9A%84%E5%9C%B0%E6%96%B9%2F</url>
    <content type="text"><![CDATA[1. 134页 \u00D7 书上误勘为 |u00D72. 138页 第一行 open development.log建议改成open log/development.log,因为depot应用的命令几乎全在depot主目录下执行的3. 155页 在此使用了jQuery但项目中现在并没有加载jQuery，因此会报错,建议在书中此处加入如何在项目中加载jQuery的步骤 4. 160页 assert_select ‘tr#current_item td’, ‘Programming Ruby 1.9’ 误勘为assert_select ‘tr#current_item td’, |Programming Ruby 1.9|5. 160页 本页中的最后一个”HTML”误勘为”HTM1”6. 166页12ActionCable.server.broadcast 'products', html: render_to_string('store/index', _layout: false) 从这行代码可以看出广播消息用html作为散列的键，值则是store/index这个渲染后的HTML,然后$(“.store #main”).html(data.html)来替换广播消息的值,如书中所说只替换#main中的内容。可是问题出现在这个广播消息的值，从图中可以看出，这个值不只是产品列表还有侧边栏，因此控制台也报错了，目前尚不知原因出在何处。 store/index 7. 175页123.submit &#123;margin-left: 4em;&#125; 而页面中未搜索到class=”submit”]]></content>
  </entry>
  <entry>
    <title><![CDATA[写Rails或Ruby的一些技巧]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%86%99Rails%E6%88%96Ruby%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[Ruby1.&lt;&lt;()方法是数组的常用方法,用于把值添加到数组的末尾:12345ages = []for person in @people ages &lt;&lt; person.ageend 2.Ruby为创建单词数组提供了快捷方式:123a = ['ant', 'bee', 'cat', 'dog', 'elk']等价于:a = %w&#123; ant bee cat dog elk&#125; Rails1.truncate(string)辅助方法用于显示string前80个字符2.strip_tags(string)辅助方法删除string中的HTMl标签3.sanitize(string)可以安全地使用string中的HTML代码4.number_to_currency(product.price)辅助方法格式化价格5.在数据库存储密码字段时使用指纹哈希值，类型为digest1rails g scaffold User name:string password:digest]]></content>
  </entry>
  <entry>
    <title><![CDATA[各种排序算法]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[二叉树的遍历与相关应用]]></title>
    <url>%2F2018%2F10%2F29%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[先序遍历中序遍历后序遍历打印叶子结点求树的高度二元运算表达式树及其遍历]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 4.两个排序数组的中位数]]></title>
    <url>%2F2018%2F10%2F28%2FLeetCode-4-%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: nums1 = [1, 3]nums2 = [2] 则中位数是 2.0示例 2: nums1 = [1, 2]nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 C++版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; nums3; int i = 0; int j = 0; double res; while( i &lt; nums1.size() &amp;&amp; j &lt; nums2.size()) &#123; if(nums1[i] &lt; nums2[j]) &#123; nums3.push_back(nums1[i]); i++; &#125;else&#123; nums3.push_back(nums2[j]); j++; &#125; &#125; for (int k = i; k &lt; nums1.size(); ++k) &#123; nums3.push_back(nums1[k]); &#125; for (int l = j; l &lt; nums2.size(); ++l) &#123; nums3.push_back(nums2[l]); &#125; int a = nums3.size() / 2 ; if(nums3.size() % 2 == 0) &#123; res = (nums3[a - 1] + nums3[a]) / 2.0 ; &#125;else&#123; res = nums3[a]; &#125; return res; &#125;&#125;;int main() &#123; int nums1[] = &#123;1, 3&#125;; int nums2[] = &#123;2&#125;; vector&lt;int&gt; vec1(nums1,nums1 + sizeof(nums1)/sizeof(int)); vector&lt;int&gt; vec2(nums2,nums2 + sizeof(nums2)/sizeof(int)); double res = Solution().findMedianSortedArrays(vec1, vec2); cout&lt;&lt;"中位数: "&lt;&lt;res&lt;&lt;endl; return 0;&#125; Ruby版12]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 3.无重复字符的最长子串]]></title>
    <url>%2F2018%2F10%2F28%2FLeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。示例 2: 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3: 输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 C++版12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int r = -1; int l = 0; int freq[256] = &#123;0&#125;; int res = 0; while( l &lt; s.length() ) &#123; if(r + 1 &lt; s.length() &amp;&amp; freq[s[r+1]] == 0) &#123; freq[s[++r]]++; &#125;else&#123; freq[s[l++]]--; &#125; res = max(r - l + 1 , res); &#125; return res; &#125;&#125;;int main() &#123; Solution *s = new Solution(); cout&lt;&lt;s-&gt;lengthOfLongestSubstring("abcabcbb")&lt;&lt;endl; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[各种查找算法]]></title>
    <url>%2F2018%2F10%2F27%2F%E5%90%84%E7%A7%8D%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"></content>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 文章模版]]></title>
    <url>%2F2018%2F10%2F26%2FLeetCode-%E6%96%87%E7%AB%A0%E6%A8%A1%E7%89%88%2F</url>
    <content type="text"><![CDATA[题目 C++版12 Ruby版12]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 2.两数相加]]></title>
    <url>%2F2018%2F10%2F26%2FLeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[题目给定两个非空链表来表示两个非负整数。 位数按照逆序方式存储，它们的每个节点只存储单个数字。 将两数相加返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例: 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 C++版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;iostream&gt;using namespace std;struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* res = (ListNode*)malloc(sizeof(ListNode)); ListNode* head = NULL; //是否进位 int flag = 0; ListNode* t1 = l1; ListNode* t2 = l2; //先算l1与l2等长部分相加 while(t1 != NULL &amp;&amp; t2 != NULL )&#123; ListNode* temp = (ListNode*)malloc(sizeof(ListNode)); int sum = 0; sum = t1-&gt;val + t2-&gt;val + flag; if(sum &gt;= 10) &#123; temp-&gt;val = sum % 10; flag = 1; &#125;else &#123; temp-&gt;val = sum; flag = 0; &#125; if( head == NULL ) &#123; temp-&gt;next = NULL; head = temp; res = head; &#125;else&#123; res-&gt;next = temp; res = temp; &#125; t1 = t1-&gt;next; t2 = t2-&gt;next; &#125; //t1剩余部分 while(t1 != NULL)&#123; ListNode* temp = (ListNode*)malloc(sizeof(ListNode)); int sum = 0; sum = t1-&gt;val + flag; if(sum &gt;= 10)&#123; temp-&gt;val = sum % 10; flag = 1; &#125;else&#123; temp-&gt;val = sum; flag = 0; &#125; temp-&gt;next = NULL; res-&gt;next = temp; res = temp; t1 = t1-&gt;next; &#125; //t2剩余部分 while(t2 != NULL) &#123; ListNode* temp = (ListNode*)malloc(sizeof(ListNode)); int sum = 0; sum = t2-&gt;val + flag; if(sum &gt;= 10)&#123; temp-&gt;val = sum % 10; flag = 1; &#125;else&#123; temp-&gt;val = sum; flag = 0; &#125; temp-&gt;next = NULL; res-&gt;next = temp; res = temp; t2 = t2-&gt;next; &#125; //是否进位 if(flag) &#123; ListNode* temp = (ListNode*)malloc(sizeof(ListNode)); temp-&gt;val = 1; temp-&gt;next = NULL; res-&gt;next = temp; &#125; return head; &#125;&#125;;int main() &#123; ListNode* l1 = (ListNode*)malloc(sizeof(ListNode)); ListNode* h1 = NULL; ListNode* l2 = (ListNode*)malloc(sizeof(ListNode)); ListNode* h2 = NULL; ListNode* res = (ListNode*)malloc(sizeof(ListNode)); int a1[3] = &#123;2, 4, 3&#125;; int a2[3] = &#123;5, 6, 4&#125;; for(int i=0; i &lt; 3; i++) &#123; ListNode* temp = (ListNode*)malloc(sizeof(ListNode)); temp-&gt;val = a1[i]; if(h1 == NULL) &#123; temp-&gt;next = NULL; l1 = temp; h1 = l1; &#125;else&#123; temp-&gt;next =NULL; h1-&gt;next = temp; h1 = temp; &#125; &#125; for(int i=0; i &lt; 3; i++) &#123; ListNode* temp = (ListNode*)malloc(sizeof(ListNode)); temp-&gt;val = a2[i]; if(h2 == NULL) &#123; temp-&gt;next = NULL; l2 = temp; h2 = l2; &#125;else&#123; temp-&gt;next =NULL; h2-&gt;next = temp; h2 = temp; &#125; &#125; Solution* s = new Solution(); res = s-&gt;addTwoNumbers(l1, l2); while(res != NULL) &#123; cout&lt;&lt;res-&gt;val&lt;&lt;endl; res = res-&gt;next; &#125; return 0;&#125; Ruby版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class ListNode attr_accessor :val, :next def initialize(val) @val = val @next = nil endend# @param &#123;ListNode&#125; l1# @param &#123;ListNode&#125; l2# @return &#123;ListNode&#125;def add_two_numbers(l1, l2) #头结点 result = res = ListNode.new(-1) #是否进位 flag = 0 #同位相加 while(l1 &amp;&amp; l2) sum = l1.val + l2.val + flag if sum &gt;= 10 flag = 1 else flag = 0 end #puts res.val # 是否为头结点 if res.val != -1 res.next = ListNode.new(sum % 10) res = res.next else res.val = sum % 10 end l1 = l1.next l2 = l2.next end #l1剩余部分 while(l1) sum = l1.val + flag if sum &gt;= 10 flag = 1 else flag = 0 end res.next = ListNode.new(sum % 10) l1 = l1.next res = res.next end #l2剩余部分 while(l2) sum = l2.val + flag if sum &gt;= 10 flag = 1 else flag = 0 end res.next = ListNode.new(sum % 10) l2 = l2.next res = res.next end #末尾是否还有进位 if flag == 1 res.next = ListNode.new(1) end resultendl1 = ListNode.new(1)l2 = ListNode.new(2)r = add_two_numbers(l1, l2)while r puts r.val r = r.nextend]]></content>
  </entry>
  <entry>
    <title><![CDATA[markdown常用语法]]></title>
    <url>%2F2018%2F10%2F24%2Fmarkdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[vector的用法]]></title>
    <url>%2F2018%2F10%2F24%2Fvector%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>vector</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1.两数之和]]></title>
    <url>%2F2018%2F10%2F22%2FLeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] C++版1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; int length = nums.size(); vector&lt;int&gt; result; for (int i = 0; i &lt; length; ++i) &#123; for (int j = i+1; j &lt; length; ++j) &#123; if (nums[i] + nums[j] == target) &#123; result.push_back(i); result.push_back(j); break; &#125; &#125; &#125; return result; &#125;&#125;;int main() &#123; int a[6] = &#123;1,6,8,4,10,7&#125;; vector&lt;int&gt; b; vector&lt;int&gt; result; int target = 9; b.insert(b.begin(), a, a + 6); Solution *s = new Solution(); result = s-&gt;twoSum(b, target); cout&lt;&lt;"["&lt;&lt;result[0]&lt;&lt;","&lt;&lt;result[1]&lt;&lt;"]"&lt;&lt;endl; return 0;&#125; Ruby版123456789101112131415161718192021# @param &#123;Integer[]&#125; nums# @param &#123;Integer&#125; target# @return &#123;Integer[]&#125;def two_sum(nums, target) i = 0 j = 1 while i &lt; nums.size j = i + 1 while j &lt; nums.size if nums[i] + nums[j] == target return i, j else j += 1 end end i += 1 endendnums = [9, 12, 3, 4, 51, 6, 8]puts two_sum(nums, 11)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乐观锁与悲观锁]]></title>
    <url>%2F2018%2F10%2F18%2F%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F10%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式1.Singleton（单例）模式用来保证某个类的实例只有一个。如果这个类的实例已存在则返回，不存在则创建。主要作用:作为其他对象的雏形而存在的对象，以及系统全体只存在唯一一个的对象2.Proxy（代理）模式为某个对象提供代理对象的模式。主要作用:某对象的生成代价非常大，如果还不知道是否真正的需要该对象时就事先把它生成，可能带来很大的浪费。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Error: xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun]]></title>
    <url>%2F2018%2F10%2F14%2FError-xcrun-error-invalid-active-developer-path-Library-Developer-CommandLineTools-missing-xcrun-at-Library-Developer-CommandLineTools-usr-bin-xcrun%2F</url>
    <content type="text"><![CDATA[MacOS下出现如下错误: xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun 解决方案1$ xcode-select --install]]></content>
      <tags>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[升级Mojave,出现安装macOS时发生错误或者无法验证macOS]]></title>
    <url>%2F2018%2F10%2F14%2F%E5%8D%87%E7%BA%A7Mojave-%E5%87%BA%E7%8E%B0%E5%AE%89%E8%A3%85macOS%E6%97%B6%E5%8F%91%E7%94%9F%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[升级Mojave,出现安装macOS时发生错误的解决方案 解决方法:系统偏好设置-&gt;网络-&gt;高级-&gt;DNS-&gt;改成8.8.8.8………………..………………..本以为这样就可以了，然而等了半个小时后还是无法验证macOS，然后上网搜了一堆解决方案，各种设置，重启，重新下载，安全模式等，都是碰巧。从错误提示分析，无法验证xxx，估计网络不好或者信息不匹配，信息不匹配不容易找具体原因，而网络不好估计并不是真正的网络不好，而是要科学上网。科学上网后再升级，一次就完美升级。]]></content>
      <tags>
        <tag>Mojave macOS升级 解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetbrains系列产品2018.2.4最新激活方法]]></title>
    <url>%2F2018%2F10%2F14%2FJetbrains%E7%B3%BB%E5%88%97%E4%BA%A7%E5%93%812018-2-4%E6%9C%80%E6%96%B0%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.访问下面的网站，并下载图中所示文件http://idea.lanyus.com/ 2.把刚才下载的文件拷贝到Jetbrains产品安装的bin目录下3.打开你所用的Jetbrains产品，并按照图中操作创建相关文件 4.编辑刚才创建的文件，然后在最末尾加上 -javaagent:JetbrainsCrack-3.1-release-enc.jar 即可。4.重启5.获取注册码，激活。]]></content>
      <tags>
        <tag>Jetbrains</tag>
        <tag>激活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo中不蒜子404错误解决方案]]></title>
    <url>%2F2018%2F10%2F11%2F%E4%B8%8D%E8%92%9C%E5%AD%90404%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[今天上博客突然发现网站统计人数的插件，不蒜子出现404错误，然后访问该网址，返回没有此域名的结果，最终到不蒜子官网找到原因 解决方法到themes/next/layout/_third-party/analytics/busuanzi-counter.swig替换一下网址即可 完。]]></content>
      <tags>
        <tag>解决方案</tag>
        <tag>hexo</tag>
        <tag>不蒜子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js]]></title>
    <url>%2F2018%2F09%2F28%2Fjs%2F</url>
    <content type="text"></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css]]></title>
    <url>%2F2018%2F09%2F28%2Fcss%2F</url>
    <content type="text"></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html]]></title>
    <url>%2F2018%2F09%2F28%2Fhtml%2F</url>
    <content type="text"></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular]]></title>
    <url>%2F2018%2F09%2F28%2Fangular%2F</url>
    <content type="text"></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rails常用命令]]></title>
    <url>%2F2018%2F09%2F26%2FRails%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.Rails启动1$ rails s 2.生成控制器 + 动作1$ rails g controller Welcome(控制器) index(动作) 3.REST资源生成在route.rb中添加resource :articles生成资源路由1$ rails routes 4.创建模型1$ rails g model Article(模型名称) title:string text:text 5.运行迁移1$ rails db:migrate 6.在其他环境运行迁移，如生产环境production,测试环境test1$ rails db:migrate RAILS_ENV=production 7.数据回滚1$ rails db:rollback 8.创建迁移123$ rails g migration AddPartNumberToProducts(AddXXXToYYY或者RemoveXXXFromYYY)$ rails g migration AddPartNumberToProducts part_number:string 9.添加索引1$ rails g migration AddPartNumberToProducts part_number:string:index 10.删除字段1$ rails g migration RemovePartNumberFromProducts part_number:string 11.添加新模型1$ rails g model Product name:string description:text 12.传递修饰符12$ rails g migration AddDetailsToProducts'price:decimal&#123;5,2&#125;' supplier:references&#123;polymorphic&#125; 13.回滚X步1$ rails db:rollback STEP=3 14.回滚最后X个迁移并再次运行迁移1$ rails db:migrate:redo STEP=3 15.安装数据库1$ rails db:setup 16.安装数据库1$ rails db:reset #相当于rails db:drop db:setup 17.运行指定迁移1$ rails db:migrate:up VERSION=xxxxxxxxxxxxxxxx(如20180912120000) 18.种子数据1$ rails db:seed #需先填充db/seed.rb文件 19.测试1$ rails test|test:models|test:controller 20.启用缓存1$ rails dev:cache 21.检查迁移状态的Rake任务1$ rails db:migrate:status 22.删除log文件1$ rails log:clear LOGS=test|LOGS=development 23.创建频道1$ rails g channel channel_name]]></content>
      <categories>
        <category>Rails</category>
      </categories>
      <tags>
        <tag>Rails</tag>
      </tags>
  </entry>
</search>
