<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[docker容器重启后命令不可用]]></title>
    <url>%2F2018%2F12%2F30%2Fdocker%E5%AE%B9%E5%99%A8%E9%87%8D%E5%90%AF%E5%90%8E%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.运行一个新容器1docker run -it --name=rails_api -v ~/rails/docker:/home/docker -p 3000:3000 -d ubuntu:16.04 2.安装了mysql git rvm rails运行rails new wikicat 一切正常进行 3.然后电脑关机，重启rails_api这个容器,发现rails rvm命令不能用12345678root@efac5241fe10:/home/docker/wikicat# rvmbash: rvm: command not foundroot@efac5241fe10:/home/docker/wikicat# railsbash: rails: command not foundroot@efac5241fe10:/home/docker/wikicat# gembash: gem: command not found 查了数据库，数据并没有丢失，而且系统历史命令也没丢失.请问问题可能出在哪地方？]]></content>
  </entry>
  <entry>
    <title><![CDATA[Rails API 开发环境搭建--以ubuntu16.04为例]]></title>
    <url>%2F2018%2F12%2F30%2FRails-API-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-%E4%BB%A5ubuntu16-04%E4%B8%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[0. 启动容器并共享文件(如果用docker,不用docker请略过这一步)1docker run -it --name=rails_api -v ~/rails/docker:/home/docker -p 3000:3000 -d ubuntu:16.04 2.安装RVM123456apt-get updateapt-get install curlcurl -sSL https://rvm.io/mpapis.asc | gpg --import -curl -sSL https://rvm.io/pkuczynski.asc | gpg --import -curl -L https://get.rvm.io | bash -s stablesource /etc/profile.d/rvm.sh 3.安装rvm所需系统依赖1rvm requirements --autolibs=enable 4.安装Ruby解释器(以ruby2.1.2为例)1rvm install 2.1.2 5.设置rvm使用的ruby版本1rvm use 2.1.2 6.安装Rails(以Rails4.1.4为例)1gem install rails --version=4.1.4 --no-ri --no-rdoc 7.安装git,mysql,nodejs1apt-get install vim git libmysqlclient-dev mysql-server nodejs 8.gem换源1gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/ 9.安装rails-api1gem install rails-api 10.新建项目1rails-api new wikicat -d mysql 11.进入项目,初始化数据库12cd wikicatrake db:create 12. 步骤11可能会出错，原因是mysql2版本不匹配，更改Gemfile中mysql2的版本1gem 'mysql2', '0.3.17' 13.安装mysql21bundle install 14.再次初始化数据库1rake db:create 15.如果14出错,Couldn’t create database for {“adapter”=&gt;”mysql2”…等1service mysql restart 16.在运行14，如果还出错，请看错误信息的username与password是否配置正确 17.运行rails s1rails s 18. 步骤17可能会出错,” TZInfo::DataSourceNotFound Errors”,更改Gemfile文件12gem 'tzinfo-data'bundle update 大功告成]]></content>
  </entry>
  <entry>
    <title><![CDATA[ActiveSupport::MessageEncryptor::InvalidMessage: ActiveSupport::MessageEncryptor::InvalidMessage的解决方案]]></title>
    <url>%2F2018%2F12%2F28%2FActiveSupport-MessageEncryptor-InvalidMessage-ActiveSupport-MessageEncryptor-InvalidMessage%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[在部署Rails项目时遇到错误1ActiveSupport::MessageEncryptor::InvalidMessage: ActiveSupport::MessageEncryptor::InvalidMessage 解决办法1.删除config/master.key,credentials.yml.enc,运行1EDITOR="vim --wait" bin/rails credentials:edit]]></content>
  </entry>
  <entry>
    <title><![CDATA[ArgumentError: Missing secret_key_base for production environment rails credentials:edit]]></title>
    <url>%2F2018%2F12%2F28%2FArgumentError-Missing-secret-key-base-for-production-environment-rails-credentials-edit%2F</url>
    <content type="text"><![CDATA[1.Rails在生产环境下报错1ArgumentError: Missing `secret_key_base` for 'production' environment, set this string with `rails credentials:edit` 主要原因是Rails 5.2开始config/secret.yml 变为master.key,在config下创建文件master.key,并写入一下内容12production: secret_key_base: &lt;%= ENV["SECRET_KEY_BASE"] %&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Rails项目线上部署--以Docker+Ubuntu16.04系统为例]]></title>
    <url>%2F2018%2F12%2F27%2FRails%E9%A1%B9%E7%9B%AE%E7%BA%BF%E4%B8%8A%E9%83%A8%E7%BD%B2-%E4%BB%A5Ubuntu16-04%E7%B3%BB%E7%BB%9F%E4%B8%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[1.拉取并运行容器1docker run -it ubuntu:16.04 bash 2.系统更新1sudo apt-get update 3.安装Rails12345sudo apt-get install apache2 curl git libmysqlclient-dev mysql-server nodejsgem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/ # 换源sudo apt-get install ruby2.3 ruby2.3-devsudo gem install rails --version=5.2.2 --no-ri --no-rdoc 4.上面可能会报错.解决方法:12sudo apt-get install libxml2-dev libxslt-devsudo apt-get install build-essential patch ruby-dev zlib1g-dev liblzma-dev 5.查看Rails版本1rails -v 6.安装bundler1gem install bundler 7. 克隆项目1git clone git@github.com:rubyyc/depot.git 8.安装依赖1bundle install 9.如果安装sqlite3报错1apt-get install sqlite3 libsqlite3-dev 然后1bundle install 10.安装Passenger12gem install passenger --version 5.0.29passenger install apache2-module 11.步骤10可能会有报错，不用担心,根据提示安装必要的依赖即可]]></content>
  </entry>
  <entry>
    <title><![CDATA[Rails项目中的时区问题]]></title>
    <url>%2F2018%2F12%2F26%2FRails%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.查看主机时间,确保是你想要的时区1date 2.如果不是你想要的时区,可更改时区2.1 根据提示选择数字1tzselect 2.21cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 3.添加配置config/application.rb123config.time_zone = 'Beijing' config.active_record.default_timezone = :localconfig.active_record.time_zone_aware_attributes = false 4.重启主机,重启项目即可]]></content>
      <tags>
        <tag>Rails</tag>
        <tag>时区</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为Docker镜像添加ssh服务]]></title>
    <url>%2F2018%2F12%2F20%2F%E4%B8%BADocker%E9%95%9C%E5%83%8F%E6%B7%BB%E5%8A%A0ssh%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[1.基于docker commit命令创建(以ubuntu:18.04为例)1.1 拉取镜像并更新ubuntu123docker pull ubuntu:18.04docker run -it ubuntu:18.04 bashapt-get update 1.2 安装openssh-server1apt-get install openssh-server 1.3 创建sshd文件夹并启动12mkdir -p /var/run/sshd/usr/sbin/sshd -D &amp; 1.4 查看端口映射情况12apt-get install net-toolsnetstat -tunlp 1.5 修改SSH服务的安全登录配置,取消pam登录限制1sed -ri 's/session required pam_loginuid.so/#session required pam_loginuid.so/g' /etc/pam.d/sshd 1.6 复制登录秘钥12345mkdir root/.ssh#ssh-keygen -t rsa#cat /root/.ssh/id_rsa.pub #复制秘钥(需要登录主机的公钥)apt-get install vimvim /root/.ssh/authorized_keys #粘贴到这个文件 1.7 创建自动启动ssh服务的可执行文件run.sh,并添加可执行权限1vim run.sh 内容如下:12#!/bin/bash/usr/sbin/sshd -D &amp; 1chmod +x run.sh 1.8 退出容器1exit 1.9 保存镜像1docker commit a9e sshd:ubuntu 1.10 使用镜像1docker run -p 10022:22 -d sshd:ubuntu /run.sh 2.使用Dockerfile创建2.1 创建工作目录,Dockerfile,run.sh12mkdir sshd_ubuntutouch Dockerfile run.sh 2.2]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ruby on Rails 小应用--暴力破解手机四位应用密码,并统计随机生成的密码信息]]></title>
    <url>%2F2018%2F12%2F19%2FRuby-on-Rails-%E5%B0%8F%E5%BA%94%E7%94%A8-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E6%89%8B%E6%9C%BA%E5%9B%9B%E4%BD%8D%E5%BA%94%E7%94%A8%E5%AF%86%E7%A0%81-%E5%B9%B6%E7%BB%9F%E8%AE%A1%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E7%9A%84%E5%AF%86%E7%A0%81%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[docker volume 创建后存放在主机哪个路径]]></title>
    <url>%2F2018%2F12%2F19%2Fdocker-volume-%E5%88%9B%E5%BB%BA%E5%90%8E%E5%AD%98%E6%94%BE%E5%9C%A8%E4%B8%BB%E6%9C%BA%E5%93%AA%E4%B8%AA%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[1.请问docker volume 创建后的数据卷存在主机哪个目录下?]]></content>
  </entry>
  <entry>
    <title><![CDATA[Error response from daemon: Get https://registry-1.docker.io/v2/: net/http: request canceled (Client.Timeout exceeded while awaiting headers)解决方案]]></title>
    <url>%2F2018%2F12%2F18%2FError-response-from-daemon-Get-https-registry-1-docker-io-v2-net-http-request-canceled-Client-Timeout-exceeded-while-awaiting-headers-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[docker push时出错”Error response from daemon: Get https://registry-1.docker.io/v2/: net/http: request canceled (Client.Timeout exceeded while awaiting headers)”,这个主要是网络原因1.1dig @114.114.114.114 registry-1.docker.io 2.从您输入步骤1命令后，如上图返回的ip(会变化，以您当时输入命令后返回的信息为准)中选一个3.把上面的ip添加到hosts1sudo vim /etc/hosts 54.175.43.85 registry-1.docker.io4.重启docker5.再次docker push注:ip经常会不一样，因此遇到这种错误只能重复上面的步骤，再手动更新ip]]></content>
  </entry>
  <entry>
    <title><![CDATA[denied: requested access to the resource is denied解决方案]]></title>
    <url>%2F2018%2F12%2F18%2Fdenied-requested-access-to-the-resource-is-denied%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[发布docker镜像时,出现这种错误”denied: requested access to the resource is denied”解决方案:1.确保已登录docker账号,用户名为https://hub.docker.com/页面上的用户名1docker login 2.制作镜像时tag使用user/image_name,确保user为上面的用户名，这个需要保持一致,然后push1docker push user/image_name 注:docker login 可能会遇到”Error response from daemon: Get https://registry-1.docker.io/v2/: net/http: request canceled (Client.Timeout exceeded while awaiting headers)”,请参照https://www.rubyc.cn/2018/12/18/Error-response-from-daemon-Get-https-registry-1-docker-io-v2-net-http-request-canceled-Client-Timeout-exceeded-while-awaiting-headers-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/]]></content>
      <tags>
        <tag>解决方案</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker命令]]></title>
    <url>%2F2018%2F12%2F14%2FDocker%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.查看Docker版本1docker version 2.确认实验特性是否开启1docker version -f '&#123;&#123;Server.Experimental&#125;&#125;' 3.查看运行的容器1docker ps 4.为避免每次使用Docker命令需要特权身份,可将当前用户添加到Docker用户组1sudo usermod -aG docker USER_NAME #在linux下可用，Mac下不可用 5.Docker开启Debug模式1dockerd -D -H tcp://127.0.0.1:2376 6.重启Docker1sudo service docker restart 7.下载镜像1docker pull 镜像名:标签(可选，默认最新版本) 8.列出本地主机已存在的镜像信息1docker images 9.为本地镜像添加新标签1docker tag local_image_name new_image_name 10.查看镜像的详细信息1docker inspect image_name:tag 11.搜索镜像1docker search image_name 12.查看镜像历史1docker history ubuntu 13.删除镜像1docker rmi iamge_name|ID(标签或ID) 14.查看所有存在的容器1docker ps -a 15.删除容器1docker rm ID 16.清理镜像（临时镜像和没有被使用的）1docker image prune -f 17.存出镜像1docker save -o file_name image_name 18.导入镜像1docker load -i image_file_name 19.登录Docker1docker login 20.创建容器1docker create -it image_name 21.启动容器1docker start container_id 22.创建并启动容器1docker run ubuntu /bin/echo "hello world" 23.查看某容器的输出1docker logs container_id 24.启动一个容器并将其暂停1docker run --name test --rm -it ubuntu bash 25.暂停或恢复到运行状态1docker pause|unpause container_name 26.终止容器1docker stop container_id 27.将处于终止状态的容器启动1docker start container_id 28.将正在运行的容器重启1docker restart container_id 29.进入容器(多个窗口attach同一容器会导致所有窗口执行相同的命令，为避免这种情况可使用命令30)1docker attach container_name|container_id 30.进入容器(exec)1docker exec -it container_name|container_id /bin/bash 31.强制删除正在运行的容器1docker rm -f container_name|container_id 32.导出容器1docker export -o new_file_name container_name|container_id 33.导入容器1docker import file_name tag_name 34.查看容器内进程1docker top container_name|container_id 35.查看统计信息1docker stats container_name|container_id 36.复制文件(将本地文件复制到容器内)1docker cp local_file container_name|container_id:/dir_name 37.查看容器内文件系统的变更1docker container diff container_name|container_id 38.查看端口映射1docker container port container_name|container_id 39.创建数据卷1docker volume create -d local volume_name 40.查看数据卷的详细信息1docker volume inspect volume_name 41.绑定数据卷12 42.创建数据卷容器1docker run -it -v /dbdata --name dbdata ubuntu 43.挂载数据卷容器中的数据卷12 44.备份数据卷容器中的数据卷12 45.恢复备份的数据卷容器12 46.端口映射(-P随机映射端口)1docker run -d -P image_name 47.1docker]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Docker命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rails5 安装bcrypt报错 An error occurred while installing bcrypt (3.1.12), and Bundler cannot continue.]]></title>
    <url>%2F2018%2F12%2F13%2FRails5-%E5%AE%89%E8%A3%85bcrypt%E6%8A%A5%E9%94%99-An-error-occurred-while-installing-bcrypt-3-1-12-and-Bundler-cannot-continue%2F</url>
    <content type="text"><![CDATA[按照《Rails5敏捷开发》教程进行到第14章–用户登录功能，User表中的密码字段需要存储为指纹哈希值，因此需要用到bcrypt.按照书上添加gem ‘bcrypt’, ‘~&gt;3.1.7’1bundle install 结果报错 谷歌到这些解决方法1.https://stackoverflow.com/questions/37158550/an-error-occurred-while-installing-bcrypt-3-1-11-and-bundler-cannot-continue2.http://www.itdaan.com/blog/2018/05/26/75c1d12cf8462711dd890e28d30947f.html3.https://community.bitnami.com/t/bcrypt-gem-failing-to-install-mac-os-x/214774.http://blog.champierre.com/10245.这个跟我报的错误一模一样,但我用这个方法还是不行 https://qiita.com/knoel/items/2aa35c9a5c34b3aea9286.这个是bcrpty-ruby中的issue https://github.com/codahale/bcrypt-ruby/issues/102 以上都不能解决此报错问题，请大佬帮忙看看Gemfile1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768source 'https://rubygems.org'git_source(:github) &#123; |repo| "https://github.com/#&#123;repo&#125;.git" &#125;ruby '2.3.7'# Bundle edge Rails instead: gem 'rails', github: 'rails/rails'gem 'rails', '~&gt; 5.2.2'# Use sqlite3 as the database for Active Recordgem 'sqlite3'# Use Puma as the app servergem 'puma', '~&gt; 3.11'# Use SCSS for stylesheetsgem 'sass-rails', '~&gt; 5.0'# Use Uglifier as compressor for JavaScript assetsgem 'uglifier', '&gt;= 1.3.0'# See https://github.com/rails/execjs#readme for more supported runtimes# gem 'mini_racer', platforms: :ruby#gem 'jquery-rails', '~&gt; 4.3', '&gt;= 4.3.3'gem 'jquery-ui-rails'# Use CoffeeScript for .coffee assets and viewsgem 'coffee-rails', '~&gt; 4.2'# Turbolinks makes navigating your web application faster. Read more: https://github.com/turbolinks/turbolinksgem 'turbolinks', '~&gt; 5'# Build JSON APIs with ease. Read more: https://github.com/rails/jbuildergem 'jbuilder', '~&gt; 2.5'# Use Redis adapter to run Action Cable in production# gem 'redis', '~&gt; 4.0'# Use ActiveModel has_secure_passwordgem 'bcrypt', '~&gt; 3.1.7'# gem 'bcrypt', platforms: :ruby# gem 'bcrypt', git: 'https://github.com/codahale/bcrypt-ruby.git', :require =&gt; 'bcrypt'#gem 'bcrypt', '~&gt; 3.1', '&gt;= 3.1.12'# Use ActiveStorage variant# gem 'mini_magick', '~&gt; 4.8'# Use Capistrano for deployment# gem 'capistrano-rails', group: :development# Reduces boot times through caching; required in config/boot.rbgem 'bootsnap', '&gt;= 1.1.0', require: falsegroup :development, :test do # Call 'byebug' anywhere in the code to stop execution and get a debugger console gem 'byebug', platforms: [:mri, :mingw, :x64_mingw]endgroup :development do # Access an interactive console on exception pages or by calling 'console' anywhere in the code. gem 'web-console', '&gt;= 3.3.0' gem 'listen', '&gt;= 3.0.5', '&lt; 3.2' # Spring speeds up development by keeping your application running in the background. Read more: https://github.com/rails/spring gem 'spring' gem 'spring-watcher-listen', '~&gt; 2.0.0'endgroup :test do # Adds support for Capybara system testing and selenium driver gem 'capybara', '&gt;= 2.15' gem 'selenium-webdriver' # Easy installation and use of chromedriver to run system tests with Chrome gem 'chromedriver-helper'end# Windows does not include zoneinfo files, so bundle the tzinfo-data gemgem 'tzinfo-data', platforms: [:mingw, :mswin, :x64_mingw, :jruby] 电脑是MacPro2018最新款,操作系统升级到最新版的macOS Mojave.本项目源码:https://github.com/yuanchang2018/depot 解决方案也不知是操作系统环境的问题还是Rails或Ruby版本问题，最终我在Docker下用Ruby2.3.3则正常运行。（而我mac系统下ruby2.3.7,直到安装bcrypt,才报错）因此，有一定的可能是Ruby版本导致bcrypt安装失败.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Rails5 Action Mailer 发送电子邮件--以QQ邮箱为例]]></title>
    <url>%2F2018%2F12%2F11%2FRails5-Action-Mailer-%E5%8F%91%E9%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6-%E4%BB%A5QQ%E9%82%AE%E7%AE%B1%E4%B8%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[config/environments/development.rb123456789101112131415Depot::Application.configure do config.action_mailer.delivery_method = :smtp config.action_mailer.perform_deliveries = true config.action_mailer.raise_delivery_errors = true config.action_mailer.smtp_settings = &#123; address: "smtp.qq.com", port: 25, domain: "qq.com", authentication: :plain, user_name: "your_email", password: "your_password", enable_starttls_auto: true &#125; end port应该为25，被官方文档坑了,试了半天的465,587都不对]]></content>
  </entry>
  <entry>
    <title><![CDATA[《Rails5敏捷开发》书中的一些可以改进的地方]]></title>
    <url>%2F2018%2F12%2F08%2F%E3%80%8ARails5%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E3%80%8B%E4%B9%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%AF%E4%BB%A5%E6%94%B9%E8%BF%9B%E7%9A%84%E5%9C%B0%E6%96%B9%2F</url>
    <content type="text"><![CDATA[0. 90页 image_url已验证presence: true，为何还需要验证allow_blank: true。题外话(allow_blank意思为允许为空，为啥值要用true，而非false)123456789class Product &lt; ApplicationRecord validates :title, :description, :image_url, presence: true validates :price, numericality: &#123; greater_than_or_equal_to: 0.01 &#125; validates :title, uniqueness: true validates :image_url, allow_blank: true, format: &#123; with: %r&#123;\.(gif|jpg|png)|z&#125;i, message: 'must be a URL for GIF, JPG or PNG image' &#125;end 1. 134页 \u00D7 书上误勘为 |u00D72. 138页 第一行 open development.log建议改成open log/development.log,因为depot应用的命令几乎全在depot主目录下执行的3. 155页 在此使用了jQuery但项目中现在并没有加载jQuery，因此会报错,建议在书中此处加入如何在项目中加载jQuery的步骤 4. 160页 assert_select ‘tr#current_item td’, ‘Programming Ruby 1.9’ 误勘为assert_select ‘tr#current_item td’, |Programming Ruby 1.9|5. 160页 本页中的最后一个”HTML”误勘为”HTM1”6. 166页12ActionCable.server.broadcast 'products', html: render_to_string('store/index', _layout: false) 从这行代码可以看出广播消息用html作为散列的键，值则是store/index这个渲染后的HTML,然后$(“.store #main”).html(data.html)来替换广播消息的值,如书中所说只替换#main中的内容。可是问题出现在这个广播消息的值，从图中可以看出，这个值不只是产品列表还有侧边栏，因此控制台也报错了，目前尚不知原因出在何处。 store/index 7. 175页123.submit &#123;margin-left: 4em;&#125; 而页面中未搜索到class=”submit” 8. 208页最下面的form_tag,应改成1&lt;%= form_tag('/login') do&gt; 否则的话默认的路由是sessions/new.则会报错]]></content>
  </entry>
  <entry>
    <title><![CDATA[写Rails或Ruby的一些技巧]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%86%99Rails%E6%88%96Ruby%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[Ruby1.&lt;&lt;()方法是数组的常用方法,用于把值添加到数组的末尾:12345ages = []for person in @people ages &lt;&lt; person.ageend 2.Ruby为创建单词数组提供了快捷方式:123a = ['ant', 'bee', 'cat', 'dog', 'elk']等价于:a = %w&#123; ant bee cat dog elk&#125; Rails1.truncate(string)辅助方法用于显示string前80个字符2.strip_tags(string)辅助方法删除string中的HTMl标签3.sanitize(string)可以安全地使用string中的HTML代码4.number_to_currency(product.price)辅助方法格式化价格5.在数据库存储密码字段时使用指纹哈希值，类型为digest1rails g scaffold User name:string password:digest]]></content>
  </entry>
  <entry>
    <title><![CDATA[各种排序算法]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[二叉树的遍历与相关应用]]></title>
    <url>%2F2018%2F10%2F29%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[先序遍历中序遍历后序遍历打印叶子结点求树的高度二元运算表达式树及其遍历]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 4.两个排序数组的中位数]]></title>
    <url>%2F2018%2F10%2F28%2FLeetCode-4-%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: nums1 = [1, 3]nums2 = [2] 则中位数是 2.0示例 2: nums1 = [1, 2]nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 C++版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; nums3; int i = 0; int j = 0; double res; while( i &lt; nums1.size() &amp;&amp; j &lt; nums2.size()) &#123; if(nums1[i] &lt; nums2[j]) &#123; nums3.push_back(nums1[i]); i++; &#125;else&#123; nums3.push_back(nums2[j]); j++; &#125; &#125; for (int k = i; k &lt; nums1.size(); ++k) &#123; nums3.push_back(nums1[k]); &#125; for (int l = j; l &lt; nums2.size(); ++l) &#123; nums3.push_back(nums2[l]); &#125; int a = nums3.size() / 2 ; if(nums3.size() % 2 == 0) &#123; res = (nums3[a - 1] + nums3[a]) / 2.0 ; &#125;else&#123; res = nums3[a]; &#125; return res; &#125;&#125;;int main() &#123; int nums1[] = &#123;1, 3&#125;; int nums2[] = &#123;2&#125;; vector&lt;int&gt; vec1(nums1,nums1 + sizeof(nums1)/sizeof(int)); vector&lt;int&gt; vec2(nums2,nums2 + sizeof(nums2)/sizeof(int)); double res = Solution().findMedianSortedArrays(vec1, vec2); cout&lt;&lt;"中位数: "&lt;&lt;res&lt;&lt;endl; return 0;&#125; Ruby版12]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 3.无重复字符的最长子串]]></title>
    <url>%2F2018%2F10%2F28%2FLeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。示例 2: 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3: 输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 C++版12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int r = -1; int l = 0; int freq[256] = &#123;0&#125;; int res = 0; while( l &lt; s.length() ) &#123; if(r + 1 &lt; s.length() &amp;&amp; freq[s[r+1]] == 0) &#123; freq[s[++r]]++; &#125;else&#123; freq[s[l++]]--; &#125; res = max(r - l + 1 , res); &#125; return res; &#125;&#125;;int main() &#123; Solution *s = new Solution(); cout&lt;&lt;s-&gt;lengthOfLongestSubstring("abcabcbb")&lt;&lt;endl; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[各种查找算法]]></title>
    <url>%2F2018%2F10%2F27%2F%E5%90%84%E7%A7%8D%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"></content>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 文章模版]]></title>
    <url>%2F2018%2F10%2F26%2FLeetCode-%E6%96%87%E7%AB%A0%E6%A8%A1%E7%89%88%2F</url>
    <content type="text"><![CDATA[题目 C++版12 Ruby版12]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 2.两数相加]]></title>
    <url>%2F2018%2F10%2F26%2FLeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[题目给定两个非空链表来表示两个非负整数。 位数按照逆序方式存储，它们的每个节点只存储单个数字。 将两数相加返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例: 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 C++版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;iostream&gt;using namespace std;struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* res = (ListNode*)malloc(sizeof(ListNode)); ListNode* head = NULL; //是否进位 int flag = 0; ListNode* t1 = l1; ListNode* t2 = l2; //先算l1与l2等长部分相加 while(t1 != NULL &amp;&amp; t2 != NULL )&#123; ListNode* temp = (ListNode*)malloc(sizeof(ListNode)); int sum = 0; sum = t1-&gt;val + t2-&gt;val + flag; if(sum &gt;= 10) &#123; temp-&gt;val = sum % 10; flag = 1; &#125;else &#123; temp-&gt;val = sum; flag = 0; &#125; if( head == NULL ) &#123; temp-&gt;next = NULL; head = temp; res = head; &#125;else&#123; res-&gt;next = temp; res = temp; &#125; t1 = t1-&gt;next; t2 = t2-&gt;next; &#125; //t1剩余部分 while(t1 != NULL)&#123; ListNode* temp = (ListNode*)malloc(sizeof(ListNode)); int sum = 0; sum = t1-&gt;val + flag; if(sum &gt;= 10)&#123; temp-&gt;val = sum % 10; flag = 1; &#125;else&#123; temp-&gt;val = sum; flag = 0; &#125; temp-&gt;next = NULL; res-&gt;next = temp; res = temp; t1 = t1-&gt;next; &#125; //t2剩余部分 while(t2 != NULL) &#123; ListNode* temp = (ListNode*)malloc(sizeof(ListNode)); int sum = 0; sum = t2-&gt;val + flag; if(sum &gt;= 10)&#123; temp-&gt;val = sum % 10; flag = 1; &#125;else&#123; temp-&gt;val = sum; flag = 0; &#125; temp-&gt;next = NULL; res-&gt;next = temp; res = temp; t2 = t2-&gt;next; &#125; //是否进位 if(flag) &#123; ListNode* temp = (ListNode*)malloc(sizeof(ListNode)); temp-&gt;val = 1; temp-&gt;next = NULL; res-&gt;next = temp; &#125; return head; &#125;&#125;;int main() &#123; ListNode* l1 = (ListNode*)malloc(sizeof(ListNode)); ListNode* h1 = NULL; ListNode* l2 = (ListNode*)malloc(sizeof(ListNode)); ListNode* h2 = NULL; ListNode* res = (ListNode*)malloc(sizeof(ListNode)); int a1[3] = &#123;2, 4, 3&#125;; int a2[3] = &#123;5, 6, 4&#125;; for(int i=0; i &lt; 3; i++) &#123; ListNode* temp = (ListNode*)malloc(sizeof(ListNode)); temp-&gt;val = a1[i]; if(h1 == NULL) &#123; temp-&gt;next = NULL; l1 = temp; h1 = l1; &#125;else&#123; temp-&gt;next =NULL; h1-&gt;next = temp; h1 = temp; &#125; &#125; for(int i=0; i &lt; 3; i++) &#123; ListNode* temp = (ListNode*)malloc(sizeof(ListNode)); temp-&gt;val = a2[i]; if(h2 == NULL) &#123; temp-&gt;next = NULL; l2 = temp; h2 = l2; &#125;else&#123; temp-&gt;next =NULL; h2-&gt;next = temp; h2 = temp; &#125; &#125; Solution* s = new Solution(); res = s-&gt;addTwoNumbers(l1, l2); while(res != NULL) &#123; cout&lt;&lt;res-&gt;val&lt;&lt;endl; res = res-&gt;next; &#125; return 0;&#125; Ruby版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class ListNode attr_accessor :val, :next def initialize(val) @val = val @next = nil endend# @param &#123;ListNode&#125; l1# @param &#123;ListNode&#125; l2# @return &#123;ListNode&#125;def add_two_numbers(l1, l2) #头结点 result = res = ListNode.new(-1) #是否进位 flag = 0 #同位相加 while(l1 &amp;&amp; l2) sum = l1.val + l2.val + flag if sum &gt;= 10 flag = 1 else flag = 0 end #puts res.val # 是否为头结点 if res.val != -1 res.next = ListNode.new(sum % 10) res = res.next else res.val = sum % 10 end l1 = l1.next l2 = l2.next end #l1剩余部分 while(l1) sum = l1.val + flag if sum &gt;= 10 flag = 1 else flag = 0 end res.next = ListNode.new(sum % 10) l1 = l1.next res = res.next end #l2剩余部分 while(l2) sum = l2.val + flag if sum &gt;= 10 flag = 1 else flag = 0 end res.next = ListNode.new(sum % 10) l2 = l2.next res = res.next end #末尾是否还有进位 if flag == 1 res.next = ListNode.new(1) end resultendl1 = ListNode.new(1)l2 = ListNode.new(2)r = add_two_numbers(l1, l2)while r puts r.val r = r.nextend]]></content>
  </entry>
  <entry>
    <title><![CDATA[markdown常用语法]]></title>
    <url>%2F2018%2F10%2F24%2Fmarkdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[vector的用法]]></title>
    <url>%2F2018%2F10%2F24%2Fvector%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>vector</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1.两数之和]]></title>
    <url>%2F2018%2F10%2F22%2FLeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] C++版1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; int length = nums.size(); vector&lt;int&gt; result; for (int i = 0; i &lt; length; ++i) &#123; for (int j = i+1; j &lt; length; ++j) &#123; if (nums[i] + nums[j] == target) &#123; result.push_back(i); result.push_back(j); break; &#125; &#125; &#125; return result; &#125;&#125;;int main() &#123; int a[6] = &#123;1,6,8,4,10,7&#125;; vector&lt;int&gt; b; vector&lt;int&gt; result; int target = 9; b.insert(b.begin(), a, a + 6); Solution *s = new Solution(); result = s-&gt;twoSum(b, target); cout&lt;&lt;"["&lt;&lt;result[0]&lt;&lt;","&lt;&lt;result[1]&lt;&lt;"]"&lt;&lt;endl; return 0;&#125; Ruby版123456789101112131415161718192021# @param &#123;Integer[]&#125; nums# @param &#123;Integer&#125; target# @return &#123;Integer[]&#125;def two_sum(nums, target) i = 0 j = 1 while i &lt; nums.size j = i + 1 while j &lt; nums.size if nums[i] + nums[j] == target return i, j else j += 1 end end i += 1 endendnums = [9, 12, 3, 4, 51, 6, 8]puts two_sum(nums, 11)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乐观锁与悲观锁]]></title>
    <url>%2F2018%2F10%2F18%2F%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F10%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式1.Singleton（单例）模式用来保证某个类的实例只有一个。如果这个类的实例已存在则返回，不存在则创建。主要作用:作为其他对象的雏形而存在的对象，以及系统全体只存在唯一一个的对象2.Proxy（代理）模式为某个对象提供代理对象的模式。主要作用:某对象的生成代价非常大，如果还不知道是否真正的需要该对象时就事先把它生成，可能带来很大的浪费。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Error: xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun]]></title>
    <url>%2F2018%2F10%2F14%2FError-xcrun-error-invalid-active-developer-path-Library-Developer-CommandLineTools-missing-xcrun-at-Library-Developer-CommandLineTools-usr-bin-xcrun%2F</url>
    <content type="text"><![CDATA[MacOS下出现如下错误: xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun 解决方案1$ xcode-select --install]]></content>
      <tags>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[升级Mojave,出现安装macOS时发生错误或者无法验证macOS]]></title>
    <url>%2F2018%2F10%2F14%2F%E5%8D%87%E7%BA%A7Mojave-%E5%87%BA%E7%8E%B0%E5%AE%89%E8%A3%85macOS%E6%97%B6%E5%8F%91%E7%94%9F%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[升级Mojave,出现安装macOS时发生错误的解决方案 解决方法:系统偏好设置-&gt;网络-&gt;高级-&gt;DNS-&gt;改成8.8.8.8………………..………………..本以为这样就可以了，然而等了半个小时后还是无法验证macOS，然后上网搜了一堆解决方案，各种设置，重启，重新下载，安全模式等，都是碰巧。从错误提示分析，无法验证xxx，估计网络不好或者信息不匹配，信息不匹配不容易找具体原因，而网络不好估计并不是真正的网络不好，而是要科学上网。科学上网后再升级，一次就完美升级。]]></content>
      <tags>
        <tag>Mojave macOS升级 解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo中不蒜子404错误解决方案]]></title>
    <url>%2F2018%2F10%2F11%2F%E4%B8%8D%E8%92%9C%E5%AD%90404%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[今天上博客突然发现网站统计人数的插件，不蒜子出现404错误，然后访问该网址，返回没有此域名的结果，最终到不蒜子官网找到原因 解决方法到themes/next/layout/_third-party/analytics/busuanzi-counter.swig替换一下网址即可 完。]]></content>
      <tags>
        <tag>解决方案</tag>
        <tag>hexo</tag>
        <tag>不蒜子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js]]></title>
    <url>%2F2018%2F09%2F28%2Fjs%2F</url>
    <content type="text"></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css]]></title>
    <url>%2F2018%2F09%2F28%2Fcss%2F</url>
    <content type="text"></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html]]></title>
    <url>%2F2018%2F09%2F28%2Fhtml%2F</url>
    <content type="text"></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular]]></title>
    <url>%2F2018%2F09%2F28%2Fangular%2F</url>
    <content type="text"></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rails常用命令]]></title>
    <url>%2F2018%2F09%2F26%2FRails%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.Rails启动1$ rails s 2.生成控制器 + 动作1$ rails g controller Welcome(控制器) index(动作) 3.REST资源生成在route.rb中添加resource :articles生成资源路由1$ rails routes 4.创建模型1$ rails g model Article(模型名称) title:string text:text 5.运行迁移1$ rails db:migrate 6.在其他环境运行迁移，如生产环境production,测试环境test1$ rails db:migrate RAILS_ENV=production 7.数据回滚1$ rails db:rollback 8.创建迁移123$ rails g migration AddPartNumberToProducts(AddXXXToYYY或者RemoveXXXFromYYY)$ rails g migration AddPartNumberToProducts part_number:string 9.添加索引1$ rails g migration AddPartNumberToProducts part_number:string:index 10.删除字段1$ rails g migration RemovePartNumberFromProducts part_number:string 11.添加新模型1$ rails g model Product name:string description:text 12.传递修饰符12$ rails g migration AddDetailsToProducts'price:decimal&#123;5,2&#125;' supplier:references&#123;polymorphic&#125; 13.回滚X步1$ rails db:rollback STEP=3 14.回滚最后X个迁移并再次运行迁移1$ rails db:migrate:redo STEP=3 15.安装数据库1$ rails db:setup 16.安装数据库1$ rails db:reset #相当于rails db:drop db:setup 17.运行指定迁移1$ rails db:migrate:up VERSION=xxxxxxxxxxxxxxxx(如20180912120000) 18.种子数据1$ rails db:seed #需先填充db/seed.rb文件 19.测试1$ rails test|test:models|test:controller 20.启用缓存1$ rails dev:cache 21.检查迁移状态的Rake任务1$ rails db:migrate:status 22.删除log文件1$ rails log:clear LOGS=test|LOGS=development 23.创建频道1$ rails g channel channel_name]]></content>
      <categories>
        <category>Rails</category>
      </categories>
      <tags>
        <tag>Rails</tag>
      </tags>
  </entry>
</search>
